public final class MarketDataMmapAccessor implements MarketDataMmapAccessable, Sizable,clojure.lang.IObj,clojure.lang.ILookup,clojure.lang.IKeywordLookup,clojure.lang.IPersistentMap,java.util.Map,java.io.Serializable{
    public MarketDataMmapAccessor(Object, Object);
    public MarketDataMmapAccessor();
    public Object length();
    public Integer positionSymbol(Integer);
    public Integer offsetSymbol();
    public Integer lengthSymbol();
    public String putSymbol(ByteBuffer, String);
    public String putSymbol(ByteBuffer, String, Integer);
    public String getSymbol(ByteBuffer);
    public String getSymbol(ByteBuffer, Integer);
    public Integer positionInternalLatency(Integer);
    public Integer offsetInternalLatency();
    public Integer lengthInternalLatency();
    public Long putInternalLatency(ByteBuffer, Long);
    public Long putInternalLatency(ByteBuffer, Long, Integer);
    public Long getInternalLatency(ByteBuffer);
    public Long getInternalLatency(ByteBuffer, Integer);
    public Integer positionLatency(Integer);
    public Integer offsetLatency();
    public Integer lengthLatency();
    public Long putLatency(ByteBuffer, Long);
    public Long putLatency(ByteBuffer, Long, Integer);
    public Long getLatency(ByteBuffer);
    public Long getLatency(ByteBuffer, Integer);
    public Integer positionCurrency(Integer);
    public Integer offsetCurrency();
    public Integer lengthCurrency();
    public Object putCurrency(ByteBuffer, Object);
    public Object putCurrency(ByteBuffer, Object, Integer);
    public Object getCurrency(ByteBuffer);
    public Object getCurrency(ByteBuffer, Integer);
    public Integer positionVolume(Integer);
    public Integer offsetVolume();
    public Integer lengthVolume();
    public Integer putVolume(ByteBuffer, Integer);
    public Integer putVolume(ByteBuffer, Integer, Integer);
    public Integer getVolume(ByteBuffer);
    public Integer getVolume(ByteBuffer, Integer);
    public Integer positionTotalAmount(Integer);
    public Integer offsetTotalAmount();
    public Integer lengthTotalAmount();
    public Long putTotalAmount(ByteBuffer, Long);
    public Long putTotalAmount(ByteBuffer, Long, Integer);
    public Long getTotalAmount(ByteBuffer);
    public Long getTotalAmount(ByteBuffer, Integer);
    public Integer positionCondition(Integer);
    public Integer offsetCondition();
    public Integer lengthCondition();
    public Object putCondition(ByteBuffer, Object);
    public Object putCondition(ByteBuffer, Object, Integer);
    public Object getCondition(ByteBuffer);
    public Object getCondition(ByteBuffer, Integer);
    public Integer positionVwap(Integer);
    public Integer offsetVwap();
    public Integer lengthVwap();
    public Float putVwap(ByteBuffer, Float);
    public Float putVwap(ByteBuffer, Float, Integer);
    public Float getVwap(ByteBuffer);
    public Float getVwap(ByteBuffer, Integer);
    public Integer positionLastSize(Integer);
    public Integer offsetLastSize();
    public Integer lengthLastSize();
    public Integer putLastSize(ByteBuffer, Integer);
    public Integer putLastSize(ByteBuffer, Integer, Integer);
    public Integer getLastSize(ByteBuffer);
    public Integer getLastSize(ByteBuffer, Integer);
    public Integer positionAskSize(Integer);
    public Integer offsetAskSize();
    public Integer lengthAskSize();
    public Integer putAskSize(ByteBuffer, Integer);
    public Integer putAskSize(ByteBuffer, Integer, Integer);
    public Integer getAskSize(ByteBuffer);
    public Integer getAskSize(ByteBuffer, Integer);
    public Integer positionBidSize(Integer);
    public Integer offsetBidSize();
    public Integer lengthBidSize();
    public Integer putBidSize(ByteBuffer, Integer);
    public Integer putBidSize(ByteBuffer, Integer, Integer);
    public Integer getBidSize(ByteBuffer);
    public Integer getBidSize(ByteBuffer, Integer);
    public Integer positionLast(Integer);
    public Integer offsetLast();
    public Integer lengthLast();
    public Float putLast(ByteBuffer, Float);
    public Float putLast(ByteBuffer, Float, Integer);
    public Float getLast(ByteBuffer);
    public Float getLast(ByteBuffer, Integer);
    public Integer positionAsk(Integer);
    public Integer offsetAsk();
    public Integer lengthAsk();
    public Float putAsk(ByteBuffer, Float);
    public Float putAsk(ByteBuffer, Float, Integer);
    public Float getAsk(ByteBuffer);
    public Float getAsk(ByteBuffer, Integer);
    public Integer positionBid(Integer);
    public Integer offsetBid();
    public Integer lengthBid();
    public Float putBid(ByteBuffer, Float);
    public Float putBid(ByteBuffer, Float, Integer);
    public Float getBid(ByteBuffer);
    public Float getBid(ByteBuffer, Integer);
    public Integer positionTradeCondition(Integer);
    public Integer offsetTradeCondition();
    public Integer lengthTradeCondition();
    public Object putTradeCondition(ByteBuffer, Object);
    public Object putTradeCondition(ByteBuffer, Object, Integer);
    public Object getTradeCondition(ByteBuffer);
    public Object getTradeCondition(ByteBuffer, Integer);
    public Integer positionQuoteCondition(Integer);
    public Integer offsetQuoteCondition();
    public Integer lengthQuoteCondition();
    public Object putQuoteCondition(ByteBuffer, Object);
    public Object putQuoteCondition(ByteBuffer, Object, Integer);
    public Object getQuoteCondition(ByteBuffer);
    public Object getQuoteCondition(ByteBuffer, Integer);
    public Integer positionTradeTime(Integer);
    public Integer offsetTradeTime();
    public Integer lengthTradeTime();
    public Long putTradeTime(ByteBuffer, Long);
    public Long putTradeTime(ByteBuffer, Long, Integer);
    public Long getTradeTime(ByteBuffer);
    public Long getTradeTime(ByteBuffer, Integer);
    public Integer positionQuoteTime(Integer);
    public Integer offsetQuoteTime();
    public Integer lengthQuoteTime();
    public Long putQuoteTime(ByteBuffer, Long);
    public Long putQuoteTime(ByteBuffer, Long, Integer);
    public Long getQuoteTime(ByteBuffer);
    public Long getQuoteTime(ByteBuffer, Integer);
    public Integer positionTimestamp(Integer);
    public Integer offsetTimestamp();
    public Integer lengthTimestamp();
    public Long putTimestamp(ByteBuffer, Long);
    public Long putTimestamp(ByteBuffer, Long, Integer);
    public Long getTimestamp(ByteBuffer);
    public Long getTimestamp(ByteBuffer, Integer);
    public int hashCode();
    public boolean equals(Object);
    public clojure.lang.IPersistentMap meta();
    public clojure.lang.IObj withMeta(clojure.lang.IPersistentMap);
    public Object valAt(Object);
    public Object valAt(Object, Object);
    public clojure.lang.ILookupThunk getLookupThunk(clojure.lang.Keyword);
    public int count();
    public clojure.lang.IPersistentCollection empty();
    public clojure.lang.IPersistentCollection cons(Object);
    public boolean equiv(Object);
    public boolean containsKey(Object);
    public clojure.lang.IMapEntry entryAt(Object);
    public clojure.lang.ISeq seq();
    public clojure.lang.IPersistentMap assoc(Object, Object);
    public clojure.lang.IPersistentMap without(Object)       throws Exception;
    public int size();
    public boolean isEmpty();
    public boolean containsValue(Object);
    public Object get(Object);
    public Object put(Object, Object);
    public Object remove(Object);
    public void putAll(java.util.Map);
    public void clear();
    public java.util.Set keySet();
    public java.util.Collection values();
    public java.util.Set entrySet();
    public clojure.lang.Associative assoc(Object, Object)       throws Exception;
}

